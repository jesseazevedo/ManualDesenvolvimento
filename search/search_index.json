{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Manual de Boas Pr\u00e1ticas para o Desenvolvedor RBCIP O presente documento tem por finalidade trazer informa\u00e7\u00f5es relevantes sobre o processo de desenvolvimento dos sistemas a serem tratados no \u00e2mbito do PROJETO DE FORTALECIMENTO DA GEST\u00c3O E GOVERNAN\u00c7A DA INFORMA\u00c7\u00c3O E COMUNICA\u00c7\u00c3O NO \u00c2MBITO DA ASSIST\u00caNCIA FARMAC\u00caUTICA NO SUS . Ser\u00e3o tratados temas como ferramentas, boas pr\u00e1ticas e diretrizes gerais que dever\u00e3o ser seguidas para um bom andamento do processo de trabalho. As orienta\u00e7\u00f5es aqui presentes ser\u00e3o exaustivas, no entanto, lembramos que o objeto de nosso trabalho tem por fim a produ\u00e7\u00e3o de c\u00f3digo livre e a solidifica\u00e7\u00e3o de um processo colaborativo onde, al\u00e9m dos desenvolvedores RBCIP, poder\u00e1 haver contribui\u00e7\u00f5es de desenvolvedores de todo o Brasil. Assim sendo, \u00e9 salutar primar pela qualidade do c\u00f3digo gerado e ado\u00e7\u00e3o de padr\u00f5es, que se tornar\u00e3o pilares de um c\u00f3digo de f\u00e1cil manutenibilidade e compreens\u00e3o. Ambiente de Desenvolvimento Para que seja poss\u00edvel o desenvolvimento, recomendamos o uso de um conjunto de ferramentas. Algumas das ferramentas postas aqui (como IDE's) s\u00e3o de escolha do desenvolvedor, que gozar\u00e1 de total liberdadde para configurar a stack que mais o agrade. Visual Studio Code Docker Community GIT","title":"Home"},{"location":"#manual-de-boas-praticas-para-o-desenvolvedor-rbcip","text":"O presente documento tem por finalidade trazer informa\u00e7\u00f5es relevantes sobre o processo de desenvolvimento dos sistemas a serem tratados no \u00e2mbito do PROJETO DE FORTALECIMENTO DA GEST\u00c3O E GOVERNAN\u00c7A DA INFORMA\u00c7\u00c3O E COMUNICA\u00c7\u00c3O NO \u00c2MBITO DA ASSIST\u00caNCIA FARMAC\u00caUTICA NO SUS . Ser\u00e3o tratados temas como ferramentas, boas pr\u00e1ticas e diretrizes gerais que dever\u00e3o ser seguidas para um bom andamento do processo de trabalho. As orienta\u00e7\u00f5es aqui presentes ser\u00e3o exaustivas, no entanto, lembramos que o objeto de nosso trabalho tem por fim a produ\u00e7\u00e3o de c\u00f3digo livre e a solidifica\u00e7\u00e3o de um processo colaborativo onde, al\u00e9m dos desenvolvedores RBCIP, poder\u00e1 haver contribui\u00e7\u00f5es de desenvolvedores de todo o Brasil. Assim sendo, \u00e9 salutar primar pela qualidade do c\u00f3digo gerado e ado\u00e7\u00e3o de padr\u00f5es, que se tornar\u00e3o pilares de um c\u00f3digo de f\u00e1cil manutenibilidade e compreens\u00e3o.","title":"Manual de Boas Pr\u00e1ticas para o Desenvolvedor RBCIP"},{"location":"#ambiente-de-desenvolvimento","text":"Para que seja poss\u00edvel o desenvolvimento, recomendamos o uso de um conjunto de ferramentas. Algumas das ferramentas postas aqui (como IDE's) s\u00e3o de escolha do desenvolvedor, que gozar\u00e1 de total liberdadde para configurar a stack que mais o agrade. Visual Studio Code Docker Community GIT","title":"Ambiente de Desenvolvimento"},{"location":"backend/","text":"Back-end Os projetos desenvolvidos pela equipe RBCIP utilizar\u00e3o para back-end o NodeJS com uso do Framework NestJS. Neste documento, discutiremos padr\u00f5es ques ser\u00e3o adotados para constru\u00e7\u00e3o desta camada bem como padr\u00e3o de diret\u00f3rios. Estrutura de Diret\u00f3rios Back-end Para tornar a experi\u00eancia do desenvolvedor mais agrad\u00e1vel, assim como no Front-end adotaremos a seguinte estrutura de diret\u00f3rios: \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 app.module.ts \u2502 \u251c\u2500\u2500 main.ts \u2502 \u251c\u2500\u2500 modules (M\u00f3dulos da aplica\u00e7\u00e3o) \u2502 \u2502 \u2514\u2500\u2500 user \u2502 \u2502 \u251c\u2500\u2500 dto (data transfer objects) \u2502 \u2502 \u251c\u2500\u2500 entities (entidades do TypeORM) \u2502 \u2502 \u251c\u2500\u2500 user.controller.ts (camada de apresenta\u00e7\u00e3o - controllers) \u2502 \u2502 \u251c\u2500\u2500 user.module.ts \u2502 \u2502 \u2514\u2500\u2500 user.service.ts (camada de servi\u00e7o - providers) \u2502 \u2514\u2500\u2500 shared \u2502 \u251c\u2500\u2500 constants (Constantes usadas pela aplica\u00e7\u00e3o) \u2502 \u251c\u2500\u2500 enums (enums usados na aplica\u00e7\u00e3o) \u2502 \u251c\u2500\u2500 helpers (c\u00f3digos comuns a toda a aplica\u00e7\u00e3o) \u2502 \u2514\u2500\u2500 interfaces (interfaces de comunica\u00e7\u00e3o com outros m\u00f3dulos) \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 user (Testes para o m\u00f3dulo) \u251c\u2500\u2500 tsconfig.build.json \u2514\u2500\u2500 tsconfig.json Conven\u00e7\u00e3o de Nomenclatura Nomes de classes devem ser escritos em PascalCase. Por exemplo: UserController, AuthService, OrderService . Nomes de m\u00e9todos e vari\u00e1veis devem ser escritos em camelCase. Por exemplo: getUserById(), createOrder() . Os nomes de propriedades devem ser escritos em camelCase. Por exemplo: firstName, age, address . Para servi\u00e7os, \u00e9 recomendado que o nome termine com o sufixo Service. Por exemplo: UserService, OrderService . Para controladores, \u00e9 recomendado que o nome termine com o sufixo Controller. Por exemplo: UserController, OrderController . Para reposit\u00f3rios, \u00e9 recomendado que o nome termine com o sufixo Repository. Por exemplo: UserRepository, OrderRepository . Os nomes dos arquivos devem ser escritos em kebab-case (separados por tra\u00e7o). Por exemplo: user.service.ts, order.controller.ts, user-profile.repository.ts . Os nomes dos arquivos devem refletir o nome da classe contida no arquivo. Por exemplo, a classe UserService deve estar definida no arquivo user.service.ts . @nestjs/swagger Para documentar as API's, al\u00e9m da documenta\u00e7\u00e3o negocial dispon\u00edvel para a aplica\u00e7\u00e3o, ser\u00e1 disponibilizado tamb\u00e9m o Swagger. Todos os recursos desenvolvidos no \u00e2mbito do projeto dever\u00e3o ter seu swagger descrito, desta forma, utilizaremos a biblioteca @nestjs/swagger. A biblioteca @nestjs/swagger \u00e9 um m\u00f3dulo oficial do NestJS que facilita a documenta\u00e7\u00e3o da API utilizando o Swagger. Com o @nestjs/swagger, \u00e9 poss\u00edvel gerar a documenta\u00e7\u00e3o da API de forma autom\u00e1tica, com base nos decorators adicionados aos endpoints. O Swagger \u00e9 uma ferramenta para documenta\u00e7\u00e3o de APIs, que permite que os desenvolvedores documentem e testem suas APIs de forma f\u00e1cil e padronizada. Ele permite que os desenvolvedores definam endpoints, par\u00e2metros e respostas, al\u00e9m de permitir testes de chamadas API diretamente na documenta\u00e7\u00e3o. O @nestjs/swagger fornece decorators para definir informa\u00e7\u00f5es sobre a API, endpoints, par\u00e2metros e respostas. Por exemplo, o decorator @ApiTags() \u00e9 usado para definir as tags da API, e o decorator @ApiOperation() \u00e9 usado para definir a descri\u00e7\u00e3o de uma opera\u00e7\u00e3o. Al\u00e9m disso, o @nestjs/swagger fornece um conjunto de recursos adicionais para personaliza\u00e7\u00e3o da documenta\u00e7\u00e3o, como a defini\u00e7\u00e3o de esquemas de resposta e a personaliza\u00e7\u00e3o de cabe\u00e7alhos e par\u00e2metros.","title":"Back-end"},{"location":"backend/#back-end","text":"Os projetos desenvolvidos pela equipe RBCIP utilizar\u00e3o para back-end o NodeJS com uso do Framework NestJS. Neste documento, discutiremos padr\u00f5es ques ser\u00e3o adotados para constru\u00e7\u00e3o desta camada bem como padr\u00e3o de diret\u00f3rios.","title":"Back-end"},{"location":"backend/#estrutura-de-diretorios-back-end","text":"Para tornar a experi\u00eancia do desenvolvedor mais agrad\u00e1vel, assim como no Front-end adotaremos a seguinte estrutura de diret\u00f3rios: \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 app.module.ts \u2502 \u251c\u2500\u2500 main.ts \u2502 \u251c\u2500\u2500 modules (M\u00f3dulos da aplica\u00e7\u00e3o) \u2502 \u2502 \u2514\u2500\u2500 user \u2502 \u2502 \u251c\u2500\u2500 dto (data transfer objects) \u2502 \u2502 \u251c\u2500\u2500 entities (entidades do TypeORM) \u2502 \u2502 \u251c\u2500\u2500 user.controller.ts (camada de apresenta\u00e7\u00e3o - controllers) \u2502 \u2502 \u251c\u2500\u2500 user.module.ts \u2502 \u2502 \u2514\u2500\u2500 user.service.ts (camada de servi\u00e7o - providers) \u2502 \u2514\u2500\u2500 shared \u2502 \u251c\u2500\u2500 constants (Constantes usadas pela aplica\u00e7\u00e3o) \u2502 \u251c\u2500\u2500 enums (enums usados na aplica\u00e7\u00e3o) \u2502 \u251c\u2500\u2500 helpers (c\u00f3digos comuns a toda a aplica\u00e7\u00e3o) \u2502 \u2514\u2500\u2500 interfaces (interfaces de comunica\u00e7\u00e3o com outros m\u00f3dulos) \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 user (Testes para o m\u00f3dulo) \u251c\u2500\u2500 tsconfig.build.json \u2514\u2500\u2500 tsconfig.json","title":"Estrutura de Diret\u00f3rios Back-end"},{"location":"backend/#convencao-de-nomenclatura","text":"Nomes de classes devem ser escritos em PascalCase. Por exemplo: UserController, AuthService, OrderService . Nomes de m\u00e9todos e vari\u00e1veis devem ser escritos em camelCase. Por exemplo: getUserById(), createOrder() . Os nomes de propriedades devem ser escritos em camelCase. Por exemplo: firstName, age, address . Para servi\u00e7os, \u00e9 recomendado que o nome termine com o sufixo Service. Por exemplo: UserService, OrderService . Para controladores, \u00e9 recomendado que o nome termine com o sufixo Controller. Por exemplo: UserController, OrderController . Para reposit\u00f3rios, \u00e9 recomendado que o nome termine com o sufixo Repository. Por exemplo: UserRepository, OrderRepository . Os nomes dos arquivos devem ser escritos em kebab-case (separados por tra\u00e7o). Por exemplo: user.service.ts, order.controller.ts, user-profile.repository.ts . Os nomes dos arquivos devem refletir o nome da classe contida no arquivo. Por exemplo, a classe UserService deve estar definida no arquivo user.service.ts .","title":"Conven\u00e7\u00e3o de Nomenclatura"},{"location":"backend/#nestjsswagger","text":"Para documentar as API's, al\u00e9m da documenta\u00e7\u00e3o negocial dispon\u00edvel para a aplica\u00e7\u00e3o, ser\u00e1 disponibilizado tamb\u00e9m o Swagger. Todos os recursos desenvolvidos no \u00e2mbito do projeto dever\u00e3o ter seu swagger descrito, desta forma, utilizaremos a biblioteca @nestjs/swagger. A biblioteca @nestjs/swagger \u00e9 um m\u00f3dulo oficial do NestJS que facilita a documenta\u00e7\u00e3o da API utilizando o Swagger. Com o @nestjs/swagger, \u00e9 poss\u00edvel gerar a documenta\u00e7\u00e3o da API de forma autom\u00e1tica, com base nos decorators adicionados aos endpoints. O Swagger \u00e9 uma ferramenta para documenta\u00e7\u00e3o de APIs, que permite que os desenvolvedores documentem e testem suas APIs de forma f\u00e1cil e padronizada. Ele permite que os desenvolvedores definam endpoints, par\u00e2metros e respostas, al\u00e9m de permitir testes de chamadas API diretamente na documenta\u00e7\u00e3o. O @nestjs/swagger fornece decorators para definir informa\u00e7\u00f5es sobre a API, endpoints, par\u00e2metros e respostas. Por exemplo, o decorator @ApiTags() \u00e9 usado para definir as tags da API, e o decorator @ApiOperation() \u00e9 usado para definir a descri\u00e7\u00e3o de uma opera\u00e7\u00e3o. Al\u00e9m disso, o @nestjs/swagger fornece um conjunto de recursos adicionais para personaliza\u00e7\u00e3o da documenta\u00e7\u00e3o, como a defini\u00e7\u00e3o de esquemas de resposta e a personaliza\u00e7\u00e3o de cabe\u00e7alhos e par\u00e2metros.","title":"@nestjs/swagger"},{"location":"database/","text":"Banco de dados No \u00e2mbito do desenvolvimento dos projetos e-SUS AF e SisDAF, ser\u00e3o utilizadas o mesmo padr\u00e3o de nomenclatura e mesma estrat\u00e9gia de migra\u00e7\u00e3o, no entanto, a estrutura de pastas poder\u00e1 mudar um pouco, posto caracteristicas espec\u00edficas de cada projeto. Em especial o e-SUS AF utilizar\u00e1 trar\u00e1 um processo de migra\u00e7\u00e3o mais cuidadoso posto a necessidade de gerenciar vers\u00f5es da aplica\u00e7\u00e3o bem como a pretens\u00e3o de homologar a aplica\u00e7\u00e3o para os SGBD's Postgres, Oracle, MySQL e SQLServer. Padr\u00e3o de nomenclatura Para a nomenclatura dos objetos de banco de dados utilizaremos o padr\u00e3o definido pelo DATASUS e publicado no documento Padroniza\u00e7\u00e3o de Nomenclatura para objetos de Banco de Dados. Para saber mais, acesse os documentos logo abaixo: Padroniza\u00e7\u00e3o de Nomenclatura para objetos de Banco de Dados Cartilha de Administra\u00e7\u00e3o de Dados Estrutura de Pastas","title":"Banco de Dados"},{"location":"database/#banco-de-dados","text":"No \u00e2mbito do desenvolvimento dos projetos e-SUS AF e SisDAF, ser\u00e3o utilizadas o mesmo padr\u00e3o de nomenclatura e mesma estrat\u00e9gia de migra\u00e7\u00e3o, no entanto, a estrutura de pastas poder\u00e1 mudar um pouco, posto caracteristicas espec\u00edficas de cada projeto. Em especial o e-SUS AF utilizar\u00e1 trar\u00e1 um processo de migra\u00e7\u00e3o mais cuidadoso posto a necessidade de gerenciar vers\u00f5es da aplica\u00e7\u00e3o bem como a pretens\u00e3o de homologar a aplica\u00e7\u00e3o para os SGBD's Postgres, Oracle, MySQL e SQLServer.","title":"Banco de dados"},{"location":"database/#padrao-de-nomenclatura","text":"Para a nomenclatura dos objetos de banco de dados utilizaremos o padr\u00e3o definido pelo DATASUS e publicado no documento Padroniza\u00e7\u00e3o de Nomenclatura para objetos de Banco de Dados. Para saber mais, acesse os documentos logo abaixo: Padroniza\u00e7\u00e3o de Nomenclatura para objetos de Banco de Dados Cartilha de Administra\u00e7\u00e3o de Dados","title":"Padr\u00e3o de nomenclatura"},{"location":"database/#estrutura-de-pastas","text":"","title":"Estrutura de Pastas"},{"location":"fluxoDeTrabalho/","text":"Fluxo de trabalho Neste m\u00f3dulo abordaremos o fluxo de trabalho da equipe e o uso do GIT como ferramenta de versionamento de c\u00f3digo de forma a orquestrar de forma harmoonica o trabalho de desenvolvimento colaborativo a ser conduzido durante o processo de desenvolvimento dos c\u00f3digos. Para o proceso de trabalho, utilizaremos o modelo/estrat\u00e9gia Git Flow. O Git Flow \u00e9 uma estrat\u00e9gia para organizar o fluxo de trabalho publicada em 2010, pelo engenheiro de software holand\u00eas Vincent Driessen. O Objetivo \u00e9 padronizar e organizar as branches dentro dos reposit\u00f3rios e, desta forma, dar fluidez ao processo de desenvolvimento de novas funcionalidades, corre\u00e7\u00f5es de bugs e lan\u00e7amentos de vers\u00f5es. Seu uso \u00e9 recomendado para projetos que utilizam versionamento sem\u00e2ntico ou que precisam oferecer suporte a v\u00e1rias vers\u00f5es do seu c\u00f3digo. Como funciona o Git Flow O Git Flow trabalha com duas branches principais, a Develop e a Master, que duram para sempre; e tr\u00eas branches de suporte, Feature, Release e Hotfix, que s\u00e3o tempor\u00e1rios e duram at\u00e9 realizar o merge com as branches principais. De forma simplificada a branch master funciona como o reposit\u00f3rio da vers\u00e3o est\u00e1vel do sistema, \u00e9 ideal que todos os commits na branch master sejam marcados (tageados) com um n\u00famero de vers\u00e3o. A Branch Developer atua como uma branch de integra\u00e7\u00e3o para recursos. Abaixo temos um modelo conceitual do que abordamos no texto. Estrat\u00e9gia de Brances Considerando o exposto, teremos sempre duas branches que ser\u00e3o mantidas durante todo o decorrer do projeto, as branchs main e develop. Outras duas branches surgir\u00e3o naturalmente a partir do processo de desenvolvimento que s\u00e3o as branches hotfix e feature. A branch feature sempre nascer\u00e1 a partir da branch develop, enquanto a branch hotfix poder\u00e1 nascer a partir da branch main ou develop. Abaixo um resumo do exposto at\u00e9 o momento: main: branch padr\u00e3o do Git. Utilizada para delimitar a vers\u00e3o de produ\u00e7\u00e3o da aplica\u00e7\u00e3o. develop: utilizada como base de desenvolvimento de features e como branch padr\u00e3o para an\u00e1lise de c\u00f3digo est\u00e1tico. feature branches: branches de funcionalidades. Utilizadas para implementar as funcionalidades que ser\u00e3o integradas na branch develop fix branches: Brnaches de corre\u00e7\u00e3o. Utilizadas para corrigir algum comportamento relacionado a uma vers\u00e3o ou release da aplica\u00e7\u00e3o, poder\u00e1 surgir a partir das branches develop ou main. Padr\u00e3o de Nomenclatura Para a nomenclatura das branches de feature e hotfix ser\u00e3o adotados padr\u00f5es conforme segue abaixo: Feature Branches: As branchs dever\u00e3o se iniciar com o prefixo feat/ seguido de uma descri\u00e7\u00e3o da feature que implantar\u00e1. Exemplo: feat/RelatorioEstoque . Hotfix Branches: As branches dever\u00e3o se iniciar com o prefixo fix/ seguido de uma descri\u00e7\u00e3o da corre\u00e7\u00e3o que prentende implantar. Exemplo: fix/TituloHome . Padr\u00e3o de Nomes para Tags","title":"Fluxo de Trabalho"},{"location":"fluxoDeTrabalho/#fluxo-de-trabalho","text":"Neste m\u00f3dulo abordaremos o fluxo de trabalho da equipe e o uso do GIT como ferramenta de versionamento de c\u00f3digo de forma a orquestrar de forma harmoonica o trabalho de desenvolvimento colaborativo a ser conduzido durante o processo de desenvolvimento dos c\u00f3digos. Para o proceso de trabalho, utilizaremos o modelo/estrat\u00e9gia Git Flow. O Git Flow \u00e9 uma estrat\u00e9gia para organizar o fluxo de trabalho publicada em 2010, pelo engenheiro de software holand\u00eas Vincent Driessen. O Objetivo \u00e9 padronizar e organizar as branches dentro dos reposit\u00f3rios e, desta forma, dar fluidez ao processo de desenvolvimento de novas funcionalidades, corre\u00e7\u00f5es de bugs e lan\u00e7amentos de vers\u00f5es. Seu uso \u00e9 recomendado para projetos que utilizam versionamento sem\u00e2ntico ou que precisam oferecer suporte a v\u00e1rias vers\u00f5es do seu c\u00f3digo.","title":"Fluxo de trabalho"},{"location":"fluxoDeTrabalho/#como-funciona-o-git-flow","text":"O Git Flow trabalha com duas branches principais, a Develop e a Master, que duram para sempre; e tr\u00eas branches de suporte, Feature, Release e Hotfix, que s\u00e3o tempor\u00e1rios e duram at\u00e9 realizar o merge com as branches principais. De forma simplificada a branch master funciona como o reposit\u00f3rio da vers\u00e3o est\u00e1vel do sistema, \u00e9 ideal que todos os commits na branch master sejam marcados (tageados) com um n\u00famero de vers\u00e3o. A Branch Developer atua como uma branch de integra\u00e7\u00e3o para recursos. Abaixo temos um modelo conceitual do que abordamos no texto.","title":"Como funciona o Git Flow"},{"location":"fluxoDeTrabalho/#estrategia-de-brances","text":"Considerando o exposto, teremos sempre duas branches que ser\u00e3o mantidas durante todo o decorrer do projeto, as branchs main e develop. Outras duas branches surgir\u00e3o naturalmente a partir do processo de desenvolvimento que s\u00e3o as branches hotfix e feature. A branch feature sempre nascer\u00e1 a partir da branch develop, enquanto a branch hotfix poder\u00e1 nascer a partir da branch main ou develop. Abaixo um resumo do exposto at\u00e9 o momento: main: branch padr\u00e3o do Git. Utilizada para delimitar a vers\u00e3o de produ\u00e7\u00e3o da aplica\u00e7\u00e3o. develop: utilizada como base de desenvolvimento de features e como branch padr\u00e3o para an\u00e1lise de c\u00f3digo est\u00e1tico. feature branches: branches de funcionalidades. Utilizadas para implementar as funcionalidades que ser\u00e3o integradas na branch develop fix branches: Brnaches de corre\u00e7\u00e3o. Utilizadas para corrigir algum comportamento relacionado a uma vers\u00e3o ou release da aplica\u00e7\u00e3o, poder\u00e1 surgir a partir das branches develop ou main.","title":"Estrat\u00e9gia de Brances"},{"location":"fluxoDeTrabalho/#padrao-de-nomenclatura","text":"Para a nomenclatura das branches de feature e hotfix ser\u00e3o adotados padr\u00f5es conforme segue abaixo: Feature Branches: As branchs dever\u00e3o se iniciar com o prefixo feat/ seguido de uma descri\u00e7\u00e3o da feature que implantar\u00e1. Exemplo: feat/RelatorioEstoque . Hotfix Branches: As branches dever\u00e3o se iniciar com o prefixo fix/ seguido de uma descri\u00e7\u00e3o da corre\u00e7\u00e3o que prentende implantar. Exemplo: fix/TituloHome .","title":"Padr\u00e3o de Nomenclatura"},{"location":"fluxoDeTrabalho/#padrao-de-nomes-para-tags","text":"","title":"Padr\u00e3o de Nomes para Tags"},{"location":"frontend/","text":"Front-end Ap\u00f3s an\u00e1lise do mercado atual e considerando que os presentes projetos ser\u00e3o mantidos tamb\u00e9m em seus estados e munic\u00edpios, optamos por desenvolver o frontend usando o React. O React \u00e9 uma popular biblioteca JS de c\u00f3digo aberto desenvolvida pela equipe do Facebook usada para criar interfaces de usu\u00e1rio. Tornou-se popular por ser f\u00e1cil, altamente flex\u00edvel e escal\u00e1vel. Atualmente \u00e9 largamente utilizada por grandes corpora\u00e7\u00f5es como a Meta, Instafram e Airbnb. Estrutura de Diret\u00f3rios Com finalidade de melhorar a experi\u00eancia dos desenvolvedores, adotaremos uma estrutura de diret\u00f3rio para todos os projetos desenvolvidos conforme segue abaixo: \u251c\u2500\u2500 public ==> Diret\u00f3rio de arquivos publicos da aplica\u00e7\u00e3o (exemplo: imagens est\u00e1ticas, fonts, svgs...) \u2502 \u251c\u2500\u2500 src \u2502 \u2514\u2500 pages ==> Diret\u00f3rio de p\u00e1ginas da aplica\u00e7\u00e3o \u2502 \u251c\u2500\u2500 _app.tsx \u2502 \u251c\u2500\u2500 _document.tsx \u2502 \u251c\u2500\u2500 index.tsx \u2502 \u2514\u2500\u2500 home-exemplo \u2502 \u2514\u2500\u2500 index.tsx \u251c\u2500\u2500 shared ====> Geralmente definimos nesse diret\u00f3rios o que \u00e9 comum a aplica\u00e7\u00e3o \u2502 \u251c\u2500\u2500 components \u2502 \u2502 \u2514\u2500\u2500 Exemplo \u2502 \u2502 \u2514\u2500\u2500 Exemplo.tsx \u2502 \u251c\u2500\u2500 constants \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 contexts \u2502 \u2502 \u2514\u2500\u2500 Exemplo \u2502 \u2502 \u2514\u2500\u2500 ExemploContext.tsx \u2502 \u251c\u2500\u2500 enums \u2502 \u2502 \u2514\u2500\u2500 routes.enum.ts \u2502 \u251c\u2500\u2500 guards \u2502 \u2502 \u2514\u2500\u2500 ExemploGuard.jsx \u2502 \u251c\u2500\u2500 hooks \u2502 \u2502 \u2514\u2500\u2500 useExemplo.jsx \u2502 \u251c\u2500\u2500 models \u2502 \u2502 \u251c\u2500\u2500 global.ts \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 services \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u2514\u2500\u2500 utils \u2502 \u2514\u2500\u2500 index.ts \u251c\u2500\u2500 modules ====> Segue mesma estrutura da pasta shared, por\u00e9m com m\u00f3dulos funcionalidades/respons\u00e1bilidade isolada \u2502 \u251c\u2500\u2500 components \u2502 \u251c\u2500\u2500 constants \u2502 \u251c\u2500\u2500 contexts \u2502 \u251c\u2500\u2500 enums \u2502 \u251c\u2500\u2500 guards \u2502 \u251c\u2500\u2500 hooks \u2502 \u251c\u2500\u2500 models \u2502 \u2514\u2500 services \u251c\u2500\u2500 store.ts \u2514\u2500\u2500 styles \u2514\u2500\u2500 globals.css Use uma arquitetura modular para organizar a aplica\u00e7\u00e3o em m\u00f3dulos espec\u00edficos. Armazene os recursos compartilhados em um diret\u00f3rio shared, como models, services, utils, enums, etc. Armazene os componentes compartilhados em um diret\u00f3rio shared/components. Armazene as p\u00e1ginas principais da aplica\u00e7\u00e3o em um diret\u00f3rio src/pages. Armazene os componentes espec\u00edficos da feature dentro dos subdiret\u00f3rios das p\u00e1ginas espec\u00edficas da feature. Evite aninhamento excessivo de diret\u00f3rios para evitar problemas de legibilidade e manuten\u00e7\u00e3o. Organiza\u00e7\u00e3o do c\u00f3digo Use interfaces para definir a forma dos objetos complexos, como modelos de dados. Use tipos TypeScript fortemente tipados sempre que poss\u00edvel para melhorar a legibilidade e evitar erros. Mantenha as fun\u00e7\u00f5es e m\u00e9todos o mais curtos poss\u00edvel, preferencialmente abaixo de 30 linhas.","title":"Front-end"},{"location":"frontend/#front-end","text":"Ap\u00f3s an\u00e1lise do mercado atual e considerando que os presentes projetos ser\u00e3o mantidos tamb\u00e9m em seus estados e munic\u00edpios, optamos por desenvolver o frontend usando o React. O React \u00e9 uma popular biblioteca JS de c\u00f3digo aberto desenvolvida pela equipe do Facebook usada para criar interfaces de usu\u00e1rio. Tornou-se popular por ser f\u00e1cil, altamente flex\u00edvel e escal\u00e1vel. Atualmente \u00e9 largamente utilizada por grandes corpora\u00e7\u00f5es como a Meta, Instafram e Airbnb.","title":"Front-end"},{"location":"frontend/#estrutura-de-diretorios","text":"Com finalidade de melhorar a experi\u00eancia dos desenvolvedores, adotaremos uma estrutura de diret\u00f3rio para todos os projetos desenvolvidos conforme segue abaixo: \u251c\u2500\u2500 public ==> Diret\u00f3rio de arquivos publicos da aplica\u00e7\u00e3o (exemplo: imagens est\u00e1ticas, fonts, svgs...) \u2502 \u251c\u2500\u2500 src \u2502 \u2514\u2500 pages ==> Diret\u00f3rio de p\u00e1ginas da aplica\u00e7\u00e3o \u2502 \u251c\u2500\u2500 _app.tsx \u2502 \u251c\u2500\u2500 _document.tsx \u2502 \u251c\u2500\u2500 index.tsx \u2502 \u2514\u2500\u2500 home-exemplo \u2502 \u2514\u2500\u2500 index.tsx \u251c\u2500\u2500 shared ====> Geralmente definimos nesse diret\u00f3rios o que \u00e9 comum a aplica\u00e7\u00e3o \u2502 \u251c\u2500\u2500 components \u2502 \u2502 \u2514\u2500\u2500 Exemplo \u2502 \u2502 \u2514\u2500\u2500 Exemplo.tsx \u2502 \u251c\u2500\u2500 constants \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 contexts \u2502 \u2502 \u2514\u2500\u2500 Exemplo \u2502 \u2502 \u2514\u2500\u2500 ExemploContext.tsx \u2502 \u251c\u2500\u2500 enums \u2502 \u2502 \u2514\u2500\u2500 routes.enum.ts \u2502 \u251c\u2500\u2500 guards \u2502 \u2502 \u2514\u2500\u2500 ExemploGuard.jsx \u2502 \u251c\u2500\u2500 hooks \u2502 \u2502 \u2514\u2500\u2500 useExemplo.jsx \u2502 \u251c\u2500\u2500 models \u2502 \u2502 \u251c\u2500\u2500 global.ts \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u251c\u2500\u2500 services \u2502 \u2502 \u2514\u2500\u2500 index.ts \u2502 \u2514\u2500\u2500 utils \u2502 \u2514\u2500\u2500 index.ts \u251c\u2500\u2500 modules ====> Segue mesma estrutura da pasta shared, por\u00e9m com m\u00f3dulos funcionalidades/respons\u00e1bilidade isolada \u2502 \u251c\u2500\u2500 components \u2502 \u251c\u2500\u2500 constants \u2502 \u251c\u2500\u2500 contexts \u2502 \u251c\u2500\u2500 enums \u2502 \u251c\u2500\u2500 guards \u2502 \u251c\u2500\u2500 hooks \u2502 \u251c\u2500\u2500 models \u2502 \u2514\u2500 services \u251c\u2500\u2500 store.ts \u2514\u2500\u2500 styles \u2514\u2500\u2500 globals.css Use uma arquitetura modular para organizar a aplica\u00e7\u00e3o em m\u00f3dulos espec\u00edficos. Armazene os recursos compartilhados em um diret\u00f3rio shared, como models, services, utils, enums, etc. Armazene os componentes compartilhados em um diret\u00f3rio shared/components. Armazene as p\u00e1ginas principais da aplica\u00e7\u00e3o em um diret\u00f3rio src/pages. Armazene os componentes espec\u00edficos da feature dentro dos subdiret\u00f3rios das p\u00e1ginas espec\u00edficas da feature. Evite aninhamento excessivo de diret\u00f3rios para evitar problemas de legibilidade e manuten\u00e7\u00e3o.","title":"Estrutura de Diret\u00f3rios"},{"location":"frontend/#organizacao-do-codigo","text":"Use interfaces para definir a forma dos objetos complexos, como modelos de dados. Use tipos TypeScript fortemente tipados sempre que poss\u00edvel para melhorar a legibilidade e evitar erros. Mantenha as fun\u00e7\u00f5es e m\u00e9todos o mais curtos poss\u00edvel, preferencialmente abaixo de 30 linhas.","title":"Organiza\u00e7\u00e3o do c\u00f3digo"},{"location":"revisoes/","text":"Estrat\u00e9gia de Revis\u00e3o de C\u00f3digo Para que uma feature possa ser incorporada a branch main ele dever\u00e1 atender aos requisitos de qualidade descritos neste documento e definidos pelo l\u00edder t\u00e9cnico da equipe. O processo de revis\u00e3o abordar\u00e1 3 pilares que culminar\u00e3o na incorpora\u00e7\u00e3o (ou n\u00e3o) de uma feature a branch main, conforme segue: Testes Automatizados : Uma feature s\u00f3 \u00e9 eleg\u00edvel a merge se apresentar ao menos testes relacionados ao fluxo b\u00e1sico e fluxos alternativos daquilo que se prop\u00f5e a implementar. Al\u00e9m disso, dever\u00e1 passar em todos os testes j\u00e1 dispon\u00edveis na aplica\u00e7\u00e3o. Revis\u00e3o de c\u00f3digo: : O c\u00f3digo dever\u00e1 passar por uma revis\u00e3o do l\u00edder t\u00e9cnico da equipe de desenvolvimento, que dever\u00e1 zelar pela qualidade do c\u00f3digo e pelos padr\u00f5es descritos neste documento. Revis\u00e3o Negocial: O c\u00f3digo dever\u00e1 ser avaliado pela equipe de neg\u00f3cio da aplica\u00e7\u00e3o que ser\u00e1 respons\u00e1vel por executar os testes de usu\u00e1rio. Apenas ap\u00f3s realizados os testes de usu\u00e1rio e aprovado pela equipe de neg\u00f3cio, uma branch poder\u00e1 ser mergeada. Abaixo, segue figura com esquema de revis\u00e3o: Testes automatizados Para os testes, ser\u00e1 priorizado a ado\u00e7\u00e3o de testes e2e (end to end) que dever\u00e3o cobrir o fluxo b\u00e1sico e fluxos alternativos da feature proposta. Quanto a inclus\u00e3o de testes unit\u00e1rios, os mesmos poder\u00e3o ser adicionados mediante necessidade identificada pelo desenvolvedor/l\u00edder t\u00e9cnico. \u00c9 importante pontuar que n\u00e3o definiremos aqui um valor m\u00ednimo de cobertura para o c\u00f3digo uma vez que a ideia \u00e9 na\u00f5 tornar custoso o processo de desenvolvimento. Para exemplificar, imaginemos a funcionalidade \"Manter Localiza\u00e7\u00e3o F\u00edsica\", o Fluxo B\u00e1sico da feature em quest\u00e3o envolve: Consultar localiza\u00e7\u00e3o f\u00edsica. Criar uma localiza\u00e7\u00e3o f\u00edsica. Alterar uma localiza\u00e7\u00e3o f\u00edsica. Desativar uma localiza\u00e7\u00e3o f\u00edsica. Os fluxos Alternativos poderiam ser: Retorna erro ao tentar criar localiza\u00e7\u00e3o f\u00edsica existente. Retorna mensagem de alerta ao desativar localiza\u00e7\u00e3o f\u00edsica com item armazenado. Retorna mensagem de alerta ao alterar o nome de uma localiza\u00e7\u00e3o f\u00edsica em uso. Retorna mensagem de insucesso ao n\u00e3o encontrar a localiza\u00e7\u00e3o f\u00edsica pesquisada. No exemplo em tela, dever\u00e3o estar presentes no m\u00ednimo 1 teste para cada um dos fluxos descritos acima. Revis\u00e3o do l\u00edder t\u00e9cnico O L\u00edder t\u00e9cnico dever\u00e1 primar pela qualidade de c\u00f3digo descrita, devendo observar o atendimento da exist\u00eancia dos testes, padr\u00e3o de diret\u00f3rios conforme descrito neste documento e boas pr\u00e1ticas a ser adotada por ele. A negativa de uma MR dever\u00e1 ser acompanhada de uma descri\u00e7\u00e3o clara das melhorias que dever\u00e3o ser realizada bem como a atribui\u00e7\u00e3o da responsabilidade ao respectivo desenvolvedor que ir\u00e1 implementar as melhorias. Revis\u00e3o Negocial Dever\u00e1 ser conduzido pelo analista de neg\u00f3cio em parceria com o PO da aplica\u00e7\u00e3o. Dever\u00e1 ser conduzida com base na documenta\u00e7\u00e3o negocial. A reprova\u00e7\u00e3o de uma feature dever\u00e1 ser acompanhada de uma descri\u00e7\u00e3o detalhada do que precisa ser feito e definido, em parceria com o l\u00edder t\u00e9cnico, o respons\u00e1vel pelo respons\u00e1vel por implementar as corre\u00e7\u00f5es/melhorias identificadas.","title":"Revis\u00e3o de C\u00f3digo"},{"location":"revisoes/#estrategia-de-revisao-de-codigo","text":"Para que uma feature possa ser incorporada a branch main ele dever\u00e1 atender aos requisitos de qualidade descritos neste documento e definidos pelo l\u00edder t\u00e9cnico da equipe. O processo de revis\u00e3o abordar\u00e1 3 pilares que culminar\u00e3o na incorpora\u00e7\u00e3o (ou n\u00e3o) de uma feature a branch main, conforme segue: Testes Automatizados : Uma feature s\u00f3 \u00e9 eleg\u00edvel a merge se apresentar ao menos testes relacionados ao fluxo b\u00e1sico e fluxos alternativos daquilo que se prop\u00f5e a implementar. Al\u00e9m disso, dever\u00e1 passar em todos os testes j\u00e1 dispon\u00edveis na aplica\u00e7\u00e3o. Revis\u00e3o de c\u00f3digo: : O c\u00f3digo dever\u00e1 passar por uma revis\u00e3o do l\u00edder t\u00e9cnico da equipe de desenvolvimento, que dever\u00e1 zelar pela qualidade do c\u00f3digo e pelos padr\u00f5es descritos neste documento. Revis\u00e3o Negocial: O c\u00f3digo dever\u00e1 ser avaliado pela equipe de neg\u00f3cio da aplica\u00e7\u00e3o que ser\u00e1 respons\u00e1vel por executar os testes de usu\u00e1rio. Apenas ap\u00f3s realizados os testes de usu\u00e1rio e aprovado pela equipe de neg\u00f3cio, uma branch poder\u00e1 ser mergeada. Abaixo, segue figura com esquema de revis\u00e3o:","title":"Estrat\u00e9gia de Revis\u00e3o de C\u00f3digo"},{"location":"revisoes/#testes-automatizados","text":"Para os testes, ser\u00e1 priorizado a ado\u00e7\u00e3o de testes e2e (end to end) que dever\u00e3o cobrir o fluxo b\u00e1sico e fluxos alternativos da feature proposta. Quanto a inclus\u00e3o de testes unit\u00e1rios, os mesmos poder\u00e3o ser adicionados mediante necessidade identificada pelo desenvolvedor/l\u00edder t\u00e9cnico. \u00c9 importante pontuar que n\u00e3o definiremos aqui um valor m\u00ednimo de cobertura para o c\u00f3digo uma vez que a ideia \u00e9 na\u00f5 tornar custoso o processo de desenvolvimento. Para exemplificar, imaginemos a funcionalidade \"Manter Localiza\u00e7\u00e3o F\u00edsica\", o Fluxo B\u00e1sico da feature em quest\u00e3o envolve: Consultar localiza\u00e7\u00e3o f\u00edsica. Criar uma localiza\u00e7\u00e3o f\u00edsica. Alterar uma localiza\u00e7\u00e3o f\u00edsica. Desativar uma localiza\u00e7\u00e3o f\u00edsica. Os fluxos Alternativos poderiam ser: Retorna erro ao tentar criar localiza\u00e7\u00e3o f\u00edsica existente. Retorna mensagem de alerta ao desativar localiza\u00e7\u00e3o f\u00edsica com item armazenado. Retorna mensagem de alerta ao alterar o nome de uma localiza\u00e7\u00e3o f\u00edsica em uso. Retorna mensagem de insucesso ao n\u00e3o encontrar a localiza\u00e7\u00e3o f\u00edsica pesquisada. No exemplo em tela, dever\u00e3o estar presentes no m\u00ednimo 1 teste para cada um dos fluxos descritos acima.","title":"Testes automatizados"},{"location":"revisoes/#revisao-do-lider-tecnico","text":"O L\u00edder t\u00e9cnico dever\u00e1 primar pela qualidade de c\u00f3digo descrita, devendo observar o atendimento da exist\u00eancia dos testes, padr\u00e3o de diret\u00f3rios conforme descrito neste documento e boas pr\u00e1ticas a ser adotada por ele. A negativa de uma MR dever\u00e1 ser acompanhada de uma descri\u00e7\u00e3o clara das melhorias que dever\u00e3o ser realizada bem como a atribui\u00e7\u00e3o da responsabilidade ao respectivo desenvolvedor que ir\u00e1 implementar as melhorias.","title":"Revis\u00e3o do l\u00edder t\u00e9cnico"},{"location":"revisoes/#revisao-negocial","text":"Dever\u00e1 ser conduzido pelo analista de neg\u00f3cio em parceria com o PO da aplica\u00e7\u00e3o. Dever\u00e1 ser conduzida com base na documenta\u00e7\u00e3o negocial. A reprova\u00e7\u00e3o de uma feature dever\u00e1 ser acompanhada de uma descri\u00e7\u00e3o detalhada do que precisa ser feito e definido, em parceria com o l\u00edder t\u00e9cnico, o respons\u00e1vel pelo respons\u00e1vel por implementar as corre\u00e7\u00f5es/melhorias identificadas.","title":"Revis\u00e3o Negocial"}]}